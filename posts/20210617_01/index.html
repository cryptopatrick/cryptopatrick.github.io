<!DOCTYPE html>
<html>
  <head>
    <title>Reading: Rust Channels ~ Tiemen</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /> <link
rel="stylesheet" href="localhost/css/main.css" />
<link rel="icon" type="image/png" sizes="16x16" href="localhost/favicon.svg" />


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-25416548-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-25416548-1");
</script>


<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="localhost/js/mathjax.js"></script>

<script type="text/javascript" src="localhost/%20js%20/jquery.js"></script>
<script type="text/javascript" src="localhost/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="localhost/js/index.js"></script>
<script type="text/javascript" src="localhost/js/mathjax.js"></script>
<meta property="og:title" content="Reading: Rust Channels ~ Tiemen" />
    <meta name="twitter:title" content="Reading: Rust Channels ~ Tiemen" />
    <meta itemprop="name" content="Reading: Rust Channels ~ Tiemen" />
    <meta name="application-name" content="Reading: Rust Channels ~ Tiemen" />
    <meta property="og:site_name" content="" />

    <meta name="keywords" content="" />

    <meta name="description" content="Notes taken from reading" />
    <meta itemprop="description" content="Notes taken from reading" />
    <meta property="og:description" content="Notes taken from reading" />
    <meta name="twitter:description" content="Notes taken from reading" />

    <link rel="canonical" href="localhost/posts/20210617_01/" itemprop="url" />
    <meta name="url" content="localhost/posts/20210617_01/" />
    <meta name="twitter:url" content="localhost/posts/20210617_01/" />
    <meta property="og:url" content="localhost/posts/20210617_01/" />
  </head>
  <body>
    <section class="single-post">
      <section class="post-pre-header">
        <a href="localhost/posts" class="bring-me-back">&larr; all posts</a>

        <div class="meta">
          Posted on Jun 17, 2021
        </div>
      </section>

      <h1>Reading: Rust Channels</h1>
      <h1 id="channels">Channels</h1>
<h2 id="imgimagesneo_01jpeg"><img src="localhost/images/neo_01.jpeg" alt="img"></h2>
<h1 id="create-a-thread">Create a thread</h1>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::thread;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::time::Duration;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5</span><span style="color:#666">    </span>thread::spawn(||{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">//Do work inside the tread
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>_i<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span><span style="color:#3677a9">1</span>..<span style="color:#3677a9">5</span><span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8</span><span style="color:#666">            </span>println!(<span style="color:#ed9d13">&#34;Ping from inside thread&#34;</span>);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9</span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// Sleep for 1 millisec
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span>thread::sleep(Duration::from_millis(<span style="color:#3677a9">1</span>));<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11</span><span style="color:#666">        </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12</span><span style="color:#666">    </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">13</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">14</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>_i<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span><span style="color:#3677a9">1</span>..<span style="color:#3677a9">5</span><span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">15</span><span style="color:#666">        </span>println!(<span style="color:#ed9d13">&#34;Ping from main thread&#34;</span>);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">16</span><span style="color:#666">        </span>thread::sleep(Duration::from_millis(<span style="color:#3677a9">1</span>));<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">17</span><span style="color:#666">    </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">18</span><span style="color:#666"></span>}<span style="color:#666">
</span></code></pre></div><h2 id="waiting-for-threads-to-finish">Waiting for threads to finish</h2>
<p>There is no guarantee on the order in which threads run.<br>
Sometimes we need to make sure that some or all threads are finished
before moving on. How do we fix this?</p>
<p>We fix the problem by saving the return value of a thread in a variable. The return type of <code>thread::spawn</code> is <code>JoinHandle</code>.
A <code>JoinHandle</code> is an <strong>owned</strong> value that, when we call <code>join</code> method on it, will <strong>wait</strong> for its thread to finish.</p>
<p>This way we can be sure that the thread will finish running before main exits and drop averything. In fact, calling <code>.join()</code> blocks the thread until the thread we called ``.join()` on has finished.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::thread;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">2</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">3</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">4</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>handle<span style="color:#666"> </span>=<span style="color:#666"> </span>thread::spawn(||{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">5</span><span style="color:#666">        </span>println!(<span style="color:#ed9d13">&#34;Working inside thread&#34;</span>);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">6</span><span style="color:#666">    </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">7</span><span style="color:#666">    
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">8</span><span style="color:#666">    </span>handle.join().unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">9</span><span style="color:#666"></span>}<span style="color:#666">
</span></code></pre></div><h2 id="using-move-to-own">Using move to own</h2>
<p>There are ties when Rust will have a hard time telling how long
a spawned thread will run. A consequence of that is that Rust having problems <strong>inferring</strong> how to capture a variable - is a borrow  enough, or does it need to be moved?</p>
<h3 id="example-of-code-causing-a-compiler-error">Example of code causing a compiler error</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::thread;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>v<span style="color:#666"> </span>=<span style="color:#666"> </span>vec![<span style="color:#3677a9">1</span>,<span style="color:#3677a9">2</span>,<span style="color:#3677a9">3</span>];<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>handle<span style="color:#666"> </span>=<span style="color:#666"> </span>thread::spawn(||{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// This is going to throw an error
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// because Rust can&#39;t infer how long borrowed v
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// is alive outside of the thread.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span>println!(<span style="color:#ed9d13">&#34;{:?}&#34;</span>,<span style="color:#666"> </span>v);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11</span><span style="color:#666">    </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12</span><span style="color:#666"></span>}<span style="color:#666">
</span></code></pre></div><h3 id="the-move-keyword">The move keyword</h3>
<p>By adding the <code>move</code> keyword before the closure that is passed to the spawned thread, we <strong>force</strong> the closure to take ownership of the values it&rsquo;s using.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">1</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">2</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>v<span style="color:#666"> </span>=<span style="color:#666"> </span>vec![<span style="color:#3677a9">1</span>,<span style="color:#3677a9">2</span>,<span style="color:#3677a9">3</span>];<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">3</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>handle<span style="color:#666"> </span>=<span style="color:#666"> </span>thread::spawn(<span style="color:#6ab825;font-weight:bold">move</span><span style="color:#666"> </span>||<span style="color:#666"> </span>{println!(<span style="color:#a61717;background-color:#e3d2d2">&#34;</span>{:?},<span style="color:#666"> </span>v);<span style="color:#666"> </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">4</span><span style="color:#666">
</span></code></pre></div><blockquote>
<p>We can use <code>drop(v)</code> at anytime to tell Rust to deallocate <code>v</code>.</p>
</blockquote>
<hr>
<h1 id="message-passing">Message Passing</h1>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=blN3rhl9W-k">https://www.youtube.com/watch?v=blN3rhl9W-k</a></p>
</blockquote>
<p>One major tool that Rust has for message-sending concurrency is the <code>channel</code>.</p>
<p>A channel in programming has <em>two halves</em> - the <em>transmitter(s)</em> (single or many) and the <em>receiver</em> (always single). So a channel can have multiple sending ends, but only one receiving end.</p>
<p>A channel is <strong>closed</strong> if either the <code>transmitter</code> or <code>receiver</code> is <strong>dropped</strong>.</p>
<p>We create a channel and move it into a spawned thread. This way the <em>spawned thread</em> will communicate with the <em>main thread</em>.</p>
<h2 id="send-and-receive">send and receive</h2>
<ul>
<li><code>tx.send(T)</code> is used to send a message acccros the channel.</li>
<li><code>rx.recv(T)</code> is used to receive a message that has been sent accross the channel</li>
</ul>
<h2 id="the-receiver">The Receiver</h2>
<p>The receiving end, <code>rx</code>, has <strong>two useful methods:</strong></p>
<h3 id="rxrecv"><code>rx.recv()</code></h3>
<p>This method will <strong>block</strong> the main thread&rsquo;s execution and wait until a value is sent down the channel.
Once a <code>message</code> (a value of some type T) is sent, <code>recv</code> will return that message in a <em>Result&lt;T,E&gt;</em>.
When the sending end of the channel closes, <code>recv</code> will return an <code>error</code> to <em>signal that no more messages will be coming</em>.</p>
<h3 id="rxtry_recv"><code>rx.try_recv()</code></h3>
<p>In contrast to <code>recv()</code>, the <code>try_recv()</code> method will <strong>not block</strong> the main thread&rsquo;s execution.<br>
<strong>Instead</strong>, it will <em>immediately</em> return an <code>Ok</code> value holding a message if one was available,
or an <code>Err</code> if a message was not available at this time.</p>
<p>Use <code>try_recv()</code> when we have other work we want to do while waiting for messages.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::sync::mpsc;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::thread;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::time::Duration;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>(tx,<span style="color:#666"> </span>rx)<span style="color:#666"> </span>=<span style="color:#666"> </span>mpsc::channel();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// We create a clone of transmitter tx
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>tx2<span style="color:#666"> </span>=<span style="color:#666"> </span>mpsc::Sender::clone(&amp;tx);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10</span><span style="color:#666">    </span>thread::spawn(<span style="color:#6ab825;font-weight:bold">move</span><span style="color:#666"> </span>||<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>vals<span style="color:#666"> </span>=<span style="color:#666"> </span>vec![<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;Hi!&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">13</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;from&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">14</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;the&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">15</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;sender&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">16</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;thread&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">17</span><span style="color:#666">        </span>];<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">18</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">19</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>val<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span>vals<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">20</span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// The spawned thread (tx2) sends the string &#34;Hi!&#34; over the channel
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">21</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// to the main thread (rx)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">22</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span>tx2.send(val).unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">23</span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// Please note that once sent the val can no longer be used because
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">24</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// tx2 passes ownership over to the receiver.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">25</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// So println!(&#34;{}&#34;, val); would throw an error, saying that val was
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">26</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// _borrowed after it was moved_
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">27</span><span style="color:#999;font-style:italic"></span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">28</span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// Sleep for 1 second
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">29</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span>thread::sleep(Duration::from_secs(<span style="color:#3677a9">1</span>));<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">30</span><span style="color:#666">        </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">31</span><span style="color:#666">    </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">32</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">33</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// Second transmitter
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">34</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span>thread::spawn(<span style="color:#6ab825;font-weight:bold">move</span><span style="color:#666"> </span>||<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">35</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>vals<span style="color:#666"> </span>=<span style="color:#666"> </span>vec![<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">36</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;more&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">37</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;messages&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">38</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;for &#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">39</span><span style="color:#666">            </span><span style="color:#24909d">String</span>::from(<span style="color:#ed9d13">&#34;you&#34;</span>),<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">40</span><span style="color:#666">        </span>];<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">41</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">42</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>val<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span>vals<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">43</span><span style="color:#666">            </span><span style="color:#999;font-style:italic">// Here we use the original transmitter.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">44</span><span style="color:#999;font-style:italic"></span><span style="color:#666">            </span>tx.send(val).unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">45</span><span style="color:#666">            </span>thread::sleep(Duration::from_secs(<span style="color:#3677a9">1</span>));<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">46</span><span style="color:#666">        </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">47</span><span style="color:#666">    </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">48</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">49</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">//let received = rx.recv().unwrap();
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">50</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">//println!(&#34;Got: {}&#34;, received);
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">51</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>received<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span>rx<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">52</span><span style="color:#666">        </span>println!(<span style="color:#ed9d13">&#34;Got: {}&#34;</span>,<span style="color:#666"> </span>received);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">53</span><span style="color:#666">    </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">54</span><span style="color:#666"></span>}<span style="color:#666">
</span></code></pre></div><h2 id="two-things-to-remember">Two things to remember:</h2>
<ul>
<li><code>tx.send()</code> needs to own the data it&rsquo;s sending over the channel
so we use <code>move</code> to make sure the passed value is taken ownership of by tx</li>
<li><code>tx.send()</code> returns a <code>Result&lt;T,E&gt;</code> so that if the receiving end has been dropped the send operation will return an error we can handle.</li>
</ul>
<p>The <code>main</code> thread in this case is the receiving end and it can collect the message that was sent by the spawned thread.</p>
<hr>
<h1 id="shared-state-concurrency">Shared-State Concurrency</h1>
<p>A <code>mutex</code> is an abbreviation for <strong>mutual exclusion</strong>.
A <code>mutex</code> allows only one <code>thread</code> to access some data at any given time.</p>
<p>In order to access the <strong>data in the mutex</strong>, a thread must <strong>first signal</strong> that it wants access.
It does so <em>by asking to <strong>acquire</strong> the mutex&rsquo;s lock</em>.</p>
<p>A <code>lock</code> is a <em>data structure</em> that is part of the <code>mutex</code>.
Its job is to keep <strong>track</strong> of who (which thread) currently has _<em>exclusive access</em>
to the mutex&rsquo;s data.</p>
<p>The <code>mutex</code> is described as guarding the data it holds, via its <code>lock</code> system.</p>
<h2 id="two-rules-of-mutexes">Two Rules of Mutexes</h2>
<ol>
<li>A thread must <em>first</em> acquire the lock, only after can it access the mutex data</li>
<li>When a thread is done using the mutex data, it has to <strong>unlock</strong> the lock,
so that other threads can attempt to acquire the lock</li>
</ol>
<blockquote>
<p>We can think of a mutex as a microphone during a panel with multiple speakers. Each speaker has to signal that they want to speak, once a speaker has the microphone that person can speak as long as they want.</p>
</blockquote>
<h2 id="lock-is-blocking">.lock() is blocking</h2>
<p>The call to <code>.lock()</code> will block the current thread.
This means that the thread can&rsquo;t do <em>any</em> other work, until it&rsquo;s our turn to have the lock.</p>
<p>The call to <code>.lock()</code> would fail if another thread was currently holding the lock
and that thread panicked. That is the reason we <code>unwrap()</code> on the call to <code>.lock()</code>.</p>
<p>The type system ensures that we acquire the lock <strong>before</strong> using the value in the Mutex.
If the Mutex data is of type <code>Mutex&lt;i32&gt;</code>, then this means that we have to acquire
the <code>lock</code> , so that we can unlock the value into an <code>i32</code> that we can use.</p>
<p>After we&rsquo;ve aquired the lock, we can treat the return value of <code>lock()</code>
as a <em>mutable reference</em> to the data inside the mutex.</p>
<p>The call to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>,
wrapped in a <code>LockResult</code>. We handle that result with <code>unwrap()</code> (which will
enable us to get the value inside). So, <code>LockResult&lt;i32&gt;.unwrap() -&gt; i32</code>.</p>
<p>The <code>MutexGuard</code> smart pointer implements <code>Deref</code> so that when we use the
dereference operator <code>*T</code>, we get the data inside the Mutex.</p>
<p>The <code>MutexGuard</code> smart pointer also has a <code>Drop</code> implementation which releases
the <code>lock</code> automatically when a <code>MutexGuard</code> goes out of scope.
By calling lock inside a scope we guard against forgetting to release the lock.</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::sync::Mutex;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// We use the Mutex associated function _new_ to create a Mutex&lt;T&gt;
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// where T is of type i32.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>m<span style="color:#666"> </span>=<span style="color:#666"> </span>Mutex::new(<span style="color:#3677a9">5</span>);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// At this point, m == 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// .lock() returns a MutexGuard type
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">mut</span><span style="color:#666"> </span>num: <span style="color:#447fcf;text-decoration:underline">MutexGuard</span>&lt;<span style="color:#6ab825;font-weight:bold">i32</span>&gt;<span style="color:#666"> </span>=<span style="color:#666"> </span>m.lock().unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// The asterix belos is the _deref_ operator
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// If we pass it a reference then it will reach what ever that
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">13</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// reference is pointing to. Since MutexGuard is a smart pointer,
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">14</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// in this case *MutexGuard&lt;i32&gt; becomes i32.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">15</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span>*num<span style="color:#666"> </span>=<span style="color:#666"> </span><span style="color:#3677a9">6</span>;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">16</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// At this point m == 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">17</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span>}<span style="color:#999;font-style:italic">// exiting this scope will make MutexGuard automatically release the lock
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">18</span><span style="color:#999;font-style:italic"></span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">19</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// At this point m == 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">20</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// So we were able to change the data inside the mutex.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">21</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span>println!(<span style="color:#ed9d13">&#34;{}&#34;</span>,<span style="color:#666"> </span>m);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">22</span><span style="color:#666"></span>}<span style="color:#666">
</span></code></pre></div><hr>
<h2 id="sharing-a-mutext-between-multiple-threads">Sharing a `Mutex<!-- raw HTML omitted --> Between Multiple Threads</h2>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::sync::Mutex;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::thread;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>counter<span style="color:#666"> </span>=<span style="color:#666"> </span>Mutex::new(<span style="color:#3677a9">0</span>);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">mut</span><span style="color:#666"> </span>handles<span style="color:#666"> </span>=<span style="color:#666"> </span>vec![];<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// Create 10 threads
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// Each thread will ask to acquire the lock
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// If the lock is granted, then the thread will increment the counter
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>_<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span><span style="color:#3677a9">0</span>..<span style="color:#3677a9">10</span><span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>handle<span style="color:#666"> </span>=<span style="color:#666"> </span>thread::spawn(<span style="color:#6ab825;font-weight:bold">move</span><span style="color:#666"> </span>||{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">13</span><span style="color:#666">            </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">mut</span><span style="color:#666"> </span>ref_counter<span style="color:#666"> </span>=<span style="color:#666"> </span>counter.lock().unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">14</span><span style="color:#666">            </span>*ref_counter<span style="color:#666"> </span>+=<span style="color:#666"> </span><span style="color:#3677a9">1</span>;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">15</span><span style="color:#666">        </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">16</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// When a thread finishes running its closure, ref_counter will go out
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">17</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// of scope and release the lock so another thread can acquire it.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">18</span><span style="color:#999;font-style:italic"></span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">19</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">20</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// Add the created thread to the collection of threads
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">21</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span>handles.push(handle);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">22</span><span style="color:#666">    </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">23</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">24</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>handle<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span>handles<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">25</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">// We call join() on each handle to make sure that each thread finishes.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">26</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span>handle.join().unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">27</span><span style="color:#666">    </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">28</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// Once all threads have finshed, the main thread will acquire the lock
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">29</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// and we can proceed to print the resulting value.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">30</span><span style="color:#999;font-style:italic"></span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">31</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// If we want to use the value inside the mutex
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">32</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// then, since .lock() returns a smart pointer
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">33</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// we have to remember to dereference it using
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">34</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#999;font-style:italic">// the dereference operator *
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">35</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span>println!(<span style="color:#ed9d13">&#34;Result: {}&#34;</span>,<span style="color:#666"> </span>*counter.lock().unwrap());<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">36</span><span style="color:#666"></span>}<span style="color:#666">
</span></code></pre></div><p>Great review of algorithmic trading from an MBA perspective. Read this along with Larry Harris to get a traders feel. Finally pick up market liquidity, the market microstructure of financial markets by frank de jong and Barbara rindi to understand the empirical and quant side of mathematics underlying market microstructure. Finally pick up &ldquo;the financial mathematics of market liquidity: from optimal execution to market making&rdquo; and another book by jaimungal to understand and model the market impact of placing orders.</p>
<hr>
<h2 id="multiple-ownership-with-multiple-threads">Multiple Ownership with Multiple Threads</h2>
<p>The naive solution below won&rsquo;t compile.<br>
The reason is that <code>Rc&lt;T&gt;</code> doesn&rsquo;t have concurrency primitives.
It simply can&rsquo;t guarantee that no thread will modify some data while another
thread owns it. We need a reference counter (rc) that does reference counting
in a thread-safe way. We need <code>Arc&lt;T&gt;</code> (Atomic reference counter).</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1</span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::thread;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">use</span><span style="color:#666"> </span>std::sync::{Arc,Mutex};<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3</span><span style="color:#666"></span><span style="color:#999;font-style:italic">//use std::rc::Rc;
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4</span><span style="color:#999;font-style:italic"></span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">fn</span> <span style="color:#447fcf">main</span>()<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">//let counter = Rc::new(Mutex::new(0));
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7</span><span style="color:#999;font-style:italic"></span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>counter<span style="color:#666"> </span>=<span style="color:#666"> </span>Arc::new(Mutex::new(<span style="color:#3677a9">0</span>));<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">mut</span><span style="color:#666"> </span>handles<span style="color:#666"> </span>=<span style="color:#666"> </span>vec![];<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>_<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span><span style="color:#3677a9">0</span>..<span style="color:#3677a9">10</span><span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11</span><span style="color:#666">        </span><span style="color:#999;font-style:italic">//let counter = Rc::clone(&amp;counter);
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12</span><span style="color:#999;font-style:italic"></span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>counter<span style="color:#666"> </span>=<span style="color:#666"> </span>Arc::clone(&amp;counter);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">13</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span>handle<span style="color:#666"> </span>=<span style="color:#666"> </span>thread::spawn(<span style="color:#6ab825;font-weight:bold">move</span><span style="color:#666"> </span>||<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">14</span><span style="color:#666">            </span><span style="color:#6ab825;font-weight:bold">let</span><span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">mut</span><span style="color:#666"> </span>num<span style="color:#666"> </span>=<span style="color:#666"> </span>counter.lock().unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">15</span><span style="color:#666">            </span>*num<span style="color:#666"> </span>+=<span style="color:#666"> </span><span style="color:#3677a9">1</span>;<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">16</span><span style="color:#666">        </span>});<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">17</span><span style="color:#666">        </span>handles.push(handle);<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">18</span><span style="color:#666">    </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">19</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">20</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">for</span><span style="color:#666"> </span>handle<span style="color:#666"> </span><span style="color:#6ab825;font-weight:bold">in</span><span style="color:#666"> </span>handles<span style="color:#666"> </span>{<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">21</span><span style="color:#666">        </span>handle.join().unwrap();<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">22</span><span style="color:#666">    </span>}<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">23</span><span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">24</span><span style="color:#666">    </span>println!(<span style="color:#ed9d13">&#34;Result: {}&#34;</span>,<span style="color:#666"> </span>*counter.lock().unwrap());<span style="color:#666">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">25</span><span style="color:#666">    </span><span style="color:#999;font-style:italic">//prints 10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">26</span><span style="color:#999;font-style:italic"></span>}<span style="color:#666">
</span></code></pre></div><hr>
<h1 id="mini-project-deadlock">Mini project: Deadlock</h1>
<blockquote>
<p>Deadlocks - these occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you’re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for Mutex<!-- raw HTML omitted --> and MutexGuard offers useful information.</p>
</blockquote>
<hr>
<h1 id="send-and-sync">Send and Sync</h1>
<p>The Rust <strong>language</strong> has <strong>very few</strong> <em>concurrency</em> features.<br>
Almost all of the concurrency features are part of the <em>standard library</em> - not the language itself.</p>
<p>Two features are embedded in the language:<br>
the <code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<h2 id="send">Send</h2>
<p>Ownership of value can be <em>transferred between threads</em> <strong>if</strong> the values are of a type that implements the <code>Send</code> trait.</p>
<p>Almost every Rust type implements <code>Send</code>, but there are exceptions, like <code>Rc&lt;T&gt;</code>. If we cloned an <code>Rc&lt;T&gt;</code> value and trie dot transfer ownership of the cloned value to another thread, then both threads might try to update the reference count at the same time.</p>
<p>If we tried to do this, then Rust would complain that:<br>
<code>the trait Send is not implemented for Rc&lt;Mutex&lt;T&gt;&gt;</code>.
If we switch to <code>Arc&lt;T&gt;</code>, which implements <code>Send</code>, then the error goes away.</p>
<h2 id="sync">Sync</h2>
<p>A type that implements <code>Sync</code> indicates that it is <strong>safe</strong> for a value of that type to be referenced from <em>multiple threads</em>.
So, a type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> (a reference to T) is <code>Send</code>, meaning the reference
can safely be <strong>sent</strong> to another thread.</p>
<h2 id="dont-try-this-at-home">Don&rsquo;t try this at home</h2>
<p>Implementing <code>Send</code> and <code>Sync</code> manually is <strong>unsafe</strong>.<br>
The reason is that doing so requires the use of <em>unsafe Rust</em>.
Building new concurrency types not made up of <code>Send</code> and <code>Sync</code>
requires careful thoguht to uphold Rust&rsquo;s safety guarantees.</p>
<blockquote>
<p>Read more about this in the Rustinomicon.</p>
</blockquote>
<hr>
<h1 id="mathjax">Mathjax</h1>
<p>$\pmb{bst\_search(root,;x)}$</p>
<p>$\pmb{input:}$ <em>root</em> (a pointer to a root of a binary search tree), and x (a number)<br>
$\pmb{output:}$ <em>node</em> (a pointer to the node containing the key , or nil if no such node exists)</p>
<p>$\pmb{begin}$<br>
$\qquad \pmb{if}; \text{root = nil}; \pmb{or}; \text{&amp;root.key = x}; \pmb{then} ; \text{node := root}$<br>
$\qquad \pmb{else}$<br>
$\qquad \qquad \pmb{if}; \text{x &lt; &amp;root.key};\pmb{then};\text{bst_search(&amp;root.left, x)}$<br>
$\qquad \qquad \pmb{else};\text{bst_search(&amp;root.right, x)}$ <br>
$\pmb{end}$</p>

    </section>
  </body>
</html>
